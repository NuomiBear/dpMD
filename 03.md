# JavaScript：this

## This

>MDN：当前执行上下文（global、function 或 eval）的一个属性，在非严格模式下，总是指向一个对象，在严格模式下可以是任意值

在JavaScript中，this的指向是调用(运行)时决定的，而不是创建时决定的，调用位置非声明位置，简单来说，this具有运行期绑定的特性

### 简单来说 在函数内部，this的值取决于函数被调用的方式

当前函数执行的主体（谁执行的函数this就是谁） this的指向和函数在哪定义以及在哪执行没有任何关系

在JS非严格模式中

- 【1】直接调用（独立调用） this一般都是window；自执行函数中的this一般都是window
  
  ```javascript
  var obj = {
      fn: (function () {
          // this -> window
          return function () { }
      })()
  }
  ```

- 【2】调用位置存在上下文对象，或者说被某个对象拥有或者包含：调用方法主体，方法执行的时候，看方法名钱买你是否有`点`，`点`前面一般为this主体（对象属性引用链中只有上一层或者说最后一层在调用位置中起作用）

  ```javascript
    var obj = {
      name: 'obj',
      fn: function () {
          console.log(this)
          }
      }

    obj.fn()    //this:obj
    var f = obj.fn
    f()     //this:window        

    [1,2,3].slice()     //this:[1,2,3]
    [1,2,3].__proto__.slice()   //this:[1,2,3].__proto__
    Array.prototype.slice()     //this:Array.prototype
  ```

- 【2】给某个元的某个事件绑定方法，当事件触发执行对应方法的时候，方法中的this一般都是当前操作的元素本身

  ```javascript
  var exampleBox = document.querySelector('.exampleBox')

  exampleBox.onclick = function () {
      // this -> exampleBox元素
      //DOM0
      console.log(this)
  }

  exampleBox.attachEvent = ('onclick', function () {
      // this -> exampleBox元素
      // IE
      console.log(this)
  })
  ```

- 【3】call、apply、bind

- 【4】new绑定：在构造函数执行的时候，函数体中的this都是当前类的实例，使用new来调用函数或者说发生构造函数调用的时候，会执行下面的操作
  - 1. 创建一个全新的对象
  - 2. 这个新对象会被执行[[prototype]]连接
  - 3. 这个新对象会被绑定到函数调用的this
  - 4. 如果函数没有返回其他对象，那么new表达式中的函数调用会自动返回这个新对象

  ```javascript
  function Fn() {
      this.name = "Fn"
      // this:当前Fn的实例(下面代码指f)
      console.log(this)
      return {}
  }
  var f1 = Fn()  // window
  var f2 = new Fn()   //{name:''fn}

  console.log(f1) // {}
  console.log(f2) // {}
  ```

- ES6箭头函数中没有执行主体，其this会继承宿主环境中的this（箭头函数较常用于回调函数中）

  MDN中对于箭头函数这一部分是这样描述的：
  > An arrow function does not create its own this, the this value of the enclosing execution context is used.
  > 箭头函数会捕获其所在上下文的this值，作为自己的this值。

  ```javascript
    var obj = {
        fn: function () {
            var _this = this
            setTimeout(function () { }, 1000)   //this:window 定时器不管在哪里执行默认this都是window
            setTimeout(function () { }.bind(this), 1000)    //This:obj
            setTimeout(function () { _this.name = 'xxx' }, 1000)    //_this:obj
            setTimeout(() => { }, 1000)     //this:obj
        }
    }

    obj.fn()
  ```

- 严格模式
  - 没有执行主体的函数，this为undefined
  - 定时器中的this指向window

#### 题目1：this

```javascript
  var num = 1, obj = {
      num: 2,
      fn: (function (num) {
          this.num *= 2
          num += 2
          return function () {
              this.num *= 3;
              num++
              console.log(num)
          }
      })(num)
  }
  var fn = obj.fn
  fn()
  obj.fn()
  console.log(num.obj.num)
```

```text
1、运行代码之前：全局num=undefined，obj=undefine，fn=undefined
2、运行第一个var代码：全局num=1、obj.num=2、fn自执行函数执行，函数内num=2（传参），this指向window所有全局num先变为2，内部num变为3，然后返回一个函数被obj.fn引用，只执行函数的执行上下文不销毁（作用域）。最后全局num=2、obj.num=2，自执行函数内的num=3
3、赋值 var fn = obj.fn 运行fn() this指向window 所以全局num*3=6，fn函数内没有num，所以通过作用域链向上查找，找到自执行函数内的num，自执行函数num变为4，obj.num不变为2
4、运行 obj.fn() 后 this指向obj 所有obj.num变为6，fn函数内没有num，所以通过作用域链向上查找，找到自执行函数内的num，自执行函数num变为5，全局num不变为6
```

#### 题目2：this

```javascript
  var num = 10
  var obj = { num: 15 }

  obj.fn = (function (num) {
      this.num += 10
      num *= 2
      return function (n) {
          this.num += n
          console.log(n + (--num))
      }
  })(obj.num)

  var fn = obj.fn
  fn(10)
  obj.fn(15)
  console.log(window.num, obj.num)
```

```text
1、运行代码之前 num=undefined，obj=undefined，fn=undefined
2、运行obj.fn自执行函数，传参15，即自执行函数内自己的num=15，this指向window，所以全局num=20，自己内部num=30，返回一个函数 obj.num不变为15
3、赋值 var fn = obj.fn 运行fn(10) this=window 所以全局num=30 fn自己内部没有num，通过作用域链找到自执行函数内部的num30 输出 10+29 =39 obj.num不变为15
4、obj.fn(15) this指向obj 所以obj.num + n =30 输出15+28（自执行函数内的num--）=43 此时 全局num为30 obj.num为30 自执行函数内num为28
```

### call、apply、bind

使用Function.prototype提供的call、apply、bind改变this

#### call

```javascript
  let obj = { name: 'Nuomi' }
  function fn(num1, num2) {
      this.total = num1 + num2
  }
  fn(10, 20)  //this:window
  obj.fn(10, 20)  //Uncaught TypeError: obj.fn is not a function

  fn.call(obj, 10, 20)    //this:obj
  fn.call(10, 20) //this:10 num1:20 num2:undefined
  fn.call()   //this:window num1=num2=undefined <=> fn()

  fn.call(null)
  fn.call(undefined)  //第一个参数不管是null还是undefined都代表没有指向得this，所以函数中的this依然是window
```

#### apply

```javascript
  let obj = { name: 'Nuomi' }
  function fn(num1, num2) {
      this.total = num1 + num2
  }

  // apply的语法和作用跟call基本上完全类似，只有一个区别
  fn.call(obj, 10, 20)    //this:obj

  // apply调用时，第一个参数是this指向，第二个参数是一个数组，数组中包含了所有需要给函数传递的实参
  fn.apply(obj, [10, 20])
```

#### bind

```javascript
  let obj = { name: 'Nuomi' }
  function fn(num1, num2) {
      this.total = num1 + num2
  }
  //改变fn中的this，并且立即执行
  fn.call(obj, 10, 20)
  //虽然改变了fn中的this，但是并没有把fn执行，属于预先处理this和实参，不会立即执行，只有达到某个条件的时候才会被出发执行
  fn.bind(obj, 10, 20)    
```

```javascript
  let obj = { name: "Nuomi" }
  function fn(num1, num2) {
      this.total = num1 + num2
  }

  // 一秒后执行fn，执行fn的时候让fn中的this->obj，并且传递两个实参10，20

  // 1s后执行，this没有改变
  setTimeout(fn, 1000)

  // 设置定时器的时候就把fn执行了，1s后执行的是fn的返回结果
  setTimeout(fn.call(obj, 10, 20), 1000)

  setTimeout(function () {
      // 1s后执行的匿名函数：fn放在匿名函数里执行
      fn.call(obj, 10, 20)
  }, 1000)

  // bind预处理
  setTimeout(fn.bind(obj, 10, 20), 1000)
```

### 深入了解This

在 `[01.md]怎么创建执行上下文` 中 我们简单提到过 `this` 

我们需要先了解一下 ECMAScript Specification Types 在 ECMAScript® 2022中:

```text
A specification type corresponds to meta-values that are used within algorithms to describe the semantics of ECMAScript language constructs and ECMAScript language types. The specification types include Reference, List, Completion Record, Property Descriptor, Environment Record, Abstract Closure, and Data Block. Specification type values are specification artefacts that do not necessarily correspond to any specific entity within an ECMAScript implementation. Specification type values may be used to describe intermediate results of ECMAScript expression evaluation but such values cannot be stored as properties of objects or values of ECMAScript language variables.
```

其中规范类型包括 Reference、List、Completion Record、Property Descriptor、Environment Record、Abstract Closure、Data Block.

其中 Reference 与 this 指向有密切的关系

#### Reference Record

`Reference Record` 在 ECMAScript® 2022中:

```text
The Reference Record type is used to explain the behaviour of such operators as delete, typeof, the assignment operators, the super keyword and other language features.
```

这里的 Reference 是一个 Specification Type，也就是 “只存在于规范里的抽象类型”。它们是为了更好地描述语言的底层行为逻辑才存在的，但并不存在于实际的 js 代码中

那么 Reference Record 的具体内容有什么，ECMAScript® 2022中：

|Field Name|Value|Meaning|
| :-----| :----- | :----- |
|[[Base]]|an ECMAScript language value, an Environment Record, or unresolvable|The value or Environment Record which holds the binding. A [[Base]] of unresolvable indicates that the binding could not be resolved.|
|[[ReferencedName]]|a String, a Symbol, or a Private Name|The name of the binding. Always a String if [[Base]] value is an Environment Record.|
|[[Strict]]|a Boolean|If not empty, the Reference Record represents a property binding that was expressed using the super keyword; it is called a Super Reference Record and its [[Base]] value will never be an Environment Record. In that case, the [[ThisValue]] field holds the this value at the time the Reference Record was created.|
|[[ThisValue]]|an ECMAScript language value or empty|If not empty, the Reference Record represents a property binding that was expressed using the super keyword; it is called a Super Reference Record and its [[Base]] value will never be an Environment Record. In that case, the [[ThisValue]] field holds the this value at the time the Reference Record was created.|

规范中还提供了一些方法: V (a Reference Record)

1. IsPropertyReference(V)
   > If V.[[Base]] is unresolvable, return false
   > If V.[[Base]] is an Environment Record, return false; otherwise return true
2. IsUnresolvableReference(V)
   > If V.[[Base]] is unresolvable, return true; otherwise return false
3. IsPrivateReference(V)
   > If V.[[ReferencedName]] is a Private Name, return true; otherwise return false
4. GetValue(V)(6.2.4.5)
5. IsSuperReference(V)
   > If V.[[ThisValue]] is not empty, return true; otherwise return false
6. GetThisValue(V)
   > Assert: IsPropertyReference(V) is true
   > If IsSuperReference(V) is true, return V.[[ThisValue]]; otherwise return V.[[Base]]

【旧版】基于 `ECMAScript 5.1（Last updated: 2015-08-11）`简单理解 Reference Record 的构成：

- base value 就是属性所在的对象或者就是 EnvironmentRecord，它的值只可能是 undefined, an Object, a Boolean, a String, a Number, or an environment record 其中的一种
- ReferencedName 就是属性的名称
- strict 是否严格模式

举个例子：

```javascript
var foo = 1;
// foo对应的Reference是：
var fooReference = {
    base: EnvironmentRecord,
    name: 'foo',
    strict: false
};
//--------------------
var foo = {
    bar: function () {
        return this;
    }
};
foo.bar(); // foo
// bar对应的Reference是：
var BarReference = {
    base: foo,
    propertyName: 'bar',
    strict: false
};
```

在早期规范中还提供了一些方法比如，比如 GetBase 和 IsPropertyReference

GetBase：Returns the base value component of the reference V（返回 reference 的 base value）

IsPropertyReference：Returns true if either the base value is an object or HasPrimitiveBase(V) is true; otherwise returns false.（简单的理解：如果 base value 是一个对象，就返回true）

除了这两个方法之外，还有一个用于从 Reference 类型获取对应值的方法：GetValue

```javascript
var foo = 1;

var fooReference = {
    base: EnvironmentRecord,
    name: 'foo',
    strict: false
};

GetValue(fooReference) // 1;
```

注意：调用GetValue返回的将是具体的值，而不再是一个Reference

#### 那么如何确定this的值呢

Function Calls 函数调用：我们看其中的几个步骤

- 1. Let ref be the result of evaluating MemberExpression
- 6. If Type(ref) is Reference, then
  - a. If IsPropertyReference(ref) is true, then
    - i.Let thisValue be GetBase(ref).
  - b. Else, the base of ref is an Environment Record
    - i.Let thisValue be the result of calling the ImplicitThisValue concrete method of GetBase(ref).
- 7. Else, Type(ref) is not Reference.
  - a. Let thisValue be undefined.

简单描述一下：

1. 判断 MemberExpression 的结果赋值给 ref
2. 判断 ref 是不是一个 Reference 类型
   1. 如果 ref 是 Reference 类型，并且 IsPropertyReference(ref) 是 true, 那么 this 的值为 GetBase(ref)
   2. 如果 ref 是 Reference 类型，并且 base value 的值是 Environment Record，那么 this 的值为 ImplicitThisValue(ref)
   3. 如果 ref 不是 Reference，那么 this 的值为 undefined

具体分析：
> 什么是 MemberExpression ：  
>> PrimaryExpression 原始表达式  
>> FunctionExpression 函数定义表达式  
>> MemberExpression [ Expression ] 属性访问表达式  
>> MemberExpression . IdentifierName 属性访问表达式  
>> new MemberExpression Arguments 对象创建表达式

举个例子：

```javascript
function foo() {
    console.log(this)
}
foo(); // MemberExpression 是 foo

function foo() {
    return function() {
        console.log(this)
    }
}
foo()(); // MemberExpression 是 foo()

var foo = {
    bar: function () {
        return this;
    }
}
foo.bar(); // MemberExpression 是 foo.bar
```

> 判断 ref 是不是一个 Reference 类型  
>> 关键就在于看规范是如何处理各种 MemberExpression ，返回的结果是不是一个 Reference 类型

举个例子：

```javascript
var value = 1;

var foo = {
  value: 2,
  bar: function () {
    return this.value;
  }
}

foo()

//示例1
console.log(foo.bar());
//示例2
console.log((foo.bar)());
//示例3
console.log((foo.bar = foo.bar)());
//示例4
console.log((false || foo.bar)());
//示例5
console.log((foo.bar, foo.bar)());
```

#### foo()

- 再示例1中：MemberExpression 的计算结果是 foo.bar,那么 foo.bar 是不是一个 Reference
- MemberExpression 执行过程：`11.2.1 Property Accessors`
  > An Identifier is evaluated by performing Identifier Resolution as specified in 10.3.1. The result of evaluating anIdentifier is always a value of type Reference.
- `10.3.1 Identifier Resolution`
  > 1.Let env be the running execution context’s LexicalEnvironment  
  > 3.Return the result of calling GetIdentifierReference function passing env, Identifier, and strict as arguments.
- 返回了 `GetIdentifierReference` 方法的结果：
  > Return a value of type whose base value is envRec, whose referenced name is name, and whose strict mode flag is strict

我们看最后返回了一个 Reference，base value 是 envRec 也就是10.3.1中传入的 execution context’s LexicalEnvironment

其抽象的数据结构大概为：

```javascript
var foo_Reference = {
    base: LexicalEnvironment,
    name: 'foo',
    strict: false
};
```

因为 evaluating MemberExpression 返回结果为 Reference，所以执行上述6，因为 base 是 Enviroment Record，所以执行6b
> Let thisValue be the result of calling the ImplicitThisValue concrete method of GetBase(ref)

10.2.1.1.6 ImplicitThisValue()
> Declarative Environment Records always return undefined as their ImplicitThisValue

到此，我们知道 foo() 执行时，thisValue = undefined，对应代码中的this，还差最后一步：
> Else if thisArg is null or undefined, set the ThisBinding to the global object

最后：foo() 执行时，this = global = window

#### foo.bar()
