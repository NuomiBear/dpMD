# JavaScript

> JavaScript 引擎
>
> - Chrome V8
> - Edge V8
> - IE Chakra
> - Firefox JaegerMonkey、TraceMonkey、SpiderMonkey
> - Opera Carakan、Futhark、Linear B、Linear A
> - Safari Nitro

## 执行栈ECS(函数调用栈)  

执行栈，在其他编程语言中也被叫做调用栈，具有 `LIFO` 数据结构，用于存储在代码执行期间创建的所有执行上下文。

`LIFO` 即 `Last In First Out`，遵循 `先进后出，后进先出` 的规则。

当 JavaScript 引擎第一次遇到脚本时，它会创建一个全局的执行上下文并且压入到当前执行栈中。每当引擎遇到一个函数调用，它会为该函创建一个新的执行上下文并压入栈的顶部。

引擎会执行那些执行上下文位于栈顶的函数。当该函数执行结束时，执行上下文从栈中退出，控制流程到达当前栈中的下一个上下文。

```JavaScript
let a = 'Hello World!';

function first() {
    console.log('Inside first function');
    second();
    console.log('Again inside first function');
}

function second() {
    console.log('Inside second function');
}

first();
console.log('Inside Global Execution Context');
```

![执行栈 顺序](01%E5%9F%BA%E7%A1%80%E6%89%A7%E8%A1%8C%E6%A0%88EN.png)

当上述代码在浏览器加载时，引擎创建了一个全局执行上下文并把它压入当前执行栈。当遇到 `first()` 函数调用时，引擎为该函数创建一个新的执行上下文并把它压入当前执行栈的顶部。

当从 `first()` 函数内部调用 `second()` 函数时，引擎为 `second()` 函数创建了一个新的执行上下文并把它压入当前执行栈的顶部。当 `second()` 函数执行完毕，它的执行上下文会从当前栈弹出，并且控制流程到达下一个执行上下文，即 `first()` 函数的执行上下而温暖。

当 `first()` 函数执行完毕，它的执行上文从栈弹出，控制流程到达全局执行上下文。一旦所有代码执行完毕，引擎从当前栈中移除全局执行上下文。

## 执行上下文EC Execution Contexts  

执行上下文是评估和执行 JavaScript 代码的环境的抽象概念。每当 JavaScript 代码运行的时候，它都是在执行上下文中运行。

> 执行上下文的类型
>
> - 全局执行上下文 —— 这是默认或者说基础的上下文，任何不在函数内部的代码都在全局上下文中。它会执行两件事：创建一个全局对象，并且设置 `this` 的值等于这个全局对象。一个程序中只会有一个全局执行上下文。
> - 函数执行上下文 —— 每当一个函数被调用的时，都会为该函数创建一个新的上下文。每个函数都有自己的执行上下文，不过是在函数被调用时创建的。函数上下文可以有任意多个。每当一个新的执行上下文被创建，它会按 `定义的顺序` 执行一系列的步骤。
> - `Eval` 函数执行上下文 —— 执行在 `Eval` 函数内部的代码也会有属它属于自己的执行上下文，但是不推荐使用，暂不讨论。

## 怎么创建执行上下文  

创建执行上下文有两个阶段 `创建阶段Creation Phase` 和 `执行阶段Execution Phase`

### The Creation Phase  

- `LexicalEnvironment` component is created（创建词法环境）  
- `VariableEnvironment` component is created（创建变量环境）  

所以，执行上下文在概念上表示：

```text
ExecutionContext = {
    ThisBinding = <this value>,
    LexicalEnvironment = <ref. to LexicalEnvironment in memory>,
    VariableEnvironment = <ref. to VariableEnvironment in memory>,
}
```

#### Lexical Environment（词法环境）

官方的ES6文档对词法环境做的定义：

> **A Lexical Environment is a specification type used to define the association of Identifiers to specific variables and functions based upon the lexical nesting structure of ECMAScript code. A Lexical Environment consists of an `Environment Record` and a possibly null reference to an outer Lexical Environment.**

翻译：

> **词法环境是一种规范类型，基于 `ECMAScript` 代码的词法嵌套结构来定义`标识符`到具体变量和函数的关联。一个词法环境由环境记录器和一个可能是null的对外部词法环境的引用。**

简单来说 `词法环境` 是一种 `标识符-变量` 映射结构。（这里的标识符指的是变量/函数的名字，变量是对实际对象[包含函数类型对象]或 `primitive value` 的引用）

```javascript
var a = 20;
var b = 40;

function foo() {
    console.log('bar');
}
```

上面代码对应的词法环境：

```text
lexicalEnvironment = {
    a: 20,
    b: 40,
    foo: <ref. to foo function>
}
```

每一个 `词法环境` 都有三个组件:

- `Environment Record` 环境记录器
- `Reference to the outer environment` 外部环境的引用
- `This binding` This绑定

> Environment Record

环境记录器是存储 `变量` 和 `函数声明` 的地方。用来描述 `Identifier` 和具体的变量或函数之间的关系，这种关系的确定基于 `词法分析`

每一个环境记录器都有一个 `[[OuterEnv]]` 字段指向 `null` 或者其它环境记录器（外部环境记录器）

环境记录器有三种类型：

- Declarative Environment Record
  - Function Environment Records
  - Module Environment Records
- Object Environment Record
- Global Environment Record

注意：对于函数环境来说，声明式环境记录器还包含了一个传递给函数的 `arguments` 对象和传递给函数的参数的 `length`

```javascript
function foo(a, b) {
    var c = a + b;
}
foo(2, 3);
// argument object
Arguments: { 0: 2, 1: 3, length: 2 },
```

#### Variable Environment

它也是一个词法环境，所以它有着词法环境定义的所有属性。

变量环境和词法环境的不同在于词法环境被用来存储函数声明和变量（`let` 和 `const`）绑定，而变量环境只用来存储变量绑定（`var`）

### The Execution Phase

在这个阶段，完成所有的变量赋值，最后执行代码

### 销毁阶段

一般来讲当函数执行完成后，当前执行上下文（局部环境）会被弹出执行上下文栈并且销毁，控制权被重新交给执行栈上一层的执行上下文。

> 特殊情况：闭包

### 代码  

我们通过一个样例代码来理解上面的概念：

```JavaScript
let a = 20;
const b = 30;
var c;

function multiply(e, f) {
    var g = 20;
    return e * f * g;
}

c = multiply(20, 30);
```

上述代码的执行上下文在伪代码中看起来像这样：

```text
GlobalExectionContext = {

  ThisBinding: <Global Object>,

  LexicalEnvironment: {
    EnvironmentRecord: {
        Type: "Object",
        a: < uninitialized >,
        b: < uninitialized >,
        multiply: < func >
    }
    outer: <null>
  },

  VariableEnvironment: {
    EnvironmentRecord: {
        Type: "Object",
        c: undefined,
    }
    outer: <null>
  }
}

FunctionExectionContext = {
  ThisBinding: <Global Object>,

  LexicalEnvironment: {
    EnvironmentRecord: {
        Type: "Declarative",
        Arguments: {0: 20, 1: 30, length: 2},
        outer: <GlobalLexicalEnvironment>
    },
  },

  VariableEnvironment: {
    EnvironmentRecord: {
        Type: "Declarative",
        g: undefined,
        outer: <GlobalLexicalEnvironment>
    },
  }
}
```

几个注意点：

- 只有遇到函数调用时，函数执行上下文才会被创建
- `let`、`const` 和 `var` 的区别（变量提升）

## 在ES6规范前的执行上下文相关内容  

- `variable object` 简称 `VO` 即 `变量对象`
- `activation object` 简称 `AO` 即 `活动对象`
- `scope chain` 即 `作用域链`
- `this` 即当前可执行代码的调用者

用伪代码来模拟一个执行上下文的组成

```javascript
//可以把执行上下文看作一个对象
ExectionContext = {
    VO =[...],  //VO代表变量对象，保存变量和函数声明
    scopeChain =[...];  //作用域链
    thisValue = { ...};  //this的值
}
```

VO变量对象

> 每个执行环境文都有一个表示变量的对象——变量对象，全局执行环境的变量对象始终存在，而函数这样局部环境的变量，只会在函数执行的过程中存在，在函数被调用时且在具体的函数代码运行之前，JS 引擎会用当前函数的参数列表（arguments）初始化一个 “变量对象” 并将当前执行上下文与之关联 ，函数代码块中声明的 变量 和 函数 将作为属性添加到这个变量对象上。

AO活动对象

> 函数进入执行阶段时，原本不能访问的变量对象被激活成为一个活动对象，自此，我们可以访问到其中的各种属性。其实变量对象和活动对象是一个东西，只不过处于不同的状态和阶段而已。也可以理解成活动对象是变量对象的一个实例。

作用域链

> 作用域 规定了如何查找变量，也就是确定当前执行代码对变量的访问权限。当查找变量的时候，会先从当前上下文的变量对象中查找，如果没有找到，就会从父级（词法层面上的父级）执行上下文的变量对象中查找，一直找到全局上下文的变量对象，也就是全局对象。这样由多个执行上下文的变量对象构成的链表就叫做 作用域链。
函数的作用域在函数创建时就已经确定了。当函数创建时，会有一个名为 `[[scope]]` 的内部属性保存所有父变量对象到其中。当函数执行时，会创建一个执行环境，然后通过复制函数的 `[[scope]]` 属性中的对象构建起执行环境的作用域链，然后，变量对象 VO 被激活生成 AO 并添加到作用域链的前端，完整作用域链创建完成：

```javascript
Scope = [AO].concat([[Scope]]);
```

this

> 如果当前函数被作为对象方法调用或使用 bind call apply 等 API 进行委托调用，则将当前代码块的调用者信息（this value）存入当前执行上下文，否则默认为全局对象调用。

一个完整的ES6规范之前的执行上下文结构表示：

```text
executionContext：{
    [variable object | activation object]：{
        arguments,
        variables: [...],
        funcions: [...]
    },
    scope chain: variable object + all parents scopes
    thisValue: context object
}
```

ES6之前函数上下文创建阶段简单总结：