# JavaScript

> JavaScript 引擎
>
> - Chrome V8
> - Edge V8
> - IE Chakra
> - Firefox JaegerMonkey、TraceMonkey、SpiderMonkey
> - Opera Carakan、Futhark、Linear B、Linear A
> - Safari Nitro

## 执行栈(函数调用栈)

执行栈，在其他编程语言中也被叫做调用栈，具有 `LIFO` 数据结构，用于存储在代码执行期间创建的所有执行上下文。

`LIFO` 即 `Last In First Out`，遵循 `先进后出，后进先出` 的规则。

当 JavaScript 引擎第一次遇到脚本时，它会创建一个全局的执行上下文并且压入到当前执行栈中。每当引擎遇到一个函数调用，它会为该函创建一个新的执行上下文并压入栈的顶部。

引擎会执行那些执行上下文位于栈顶的函数。当该函数执行结束时，执行上下文从栈中退出，控制流程到达当前栈中的下一个上下文。

```JavaScript
let a = 'Hello World!';

function first() {
    console.log('Inside first function');
    second();
    console.log('Again inside first function');
}

function second() {
    console.log('Inside second function');
}

first();
console.log('Inside Global Execution Context');
```

![执行栈 顺序](01%E5%9F%BA%E7%A1%80%E6%89%A7%E8%A1%8C%E6%A0%88EN.png)

当上述代码在浏览器加载时，引擎创建了一个全局执行上下文并把它压入当前执行栈。当遇到 `first()` 函数调用时，引擎为该函数创建一个新的执行上下文并把它压入当前执行栈的顶部。

当从 `first()` 函数内部调用 `second()` 函数时，引擎为 `second()` 函数创建了一个新的执行上下文并把它压入当前执行栈的顶部。当 `second()` 函数执行完毕，它的执行上下文会从当前栈弹出，并且控制流程到达下一个执行上下文，即 `first()` 函数的执行上下而温暖。

当 `first()` 函数执行完毕，它的执行上文从栈弹出，控制流程到达全局执行上下文。一旦所有代码执行完毕，引擎从当前栈中移除全局执行上下文。

## 执行上下文  

执行上下文是评估和执行 JavaScript 代码的环境的抽象概念。每当 JavaScript 代码运行的时候，它都是在执行上下文中运行。

> 执行上下文的类型
>
> - 全局执行上下文 —— 这是默认或者说基础的上下文，任何不在函数内部的代码都在全局上下文中。它会执行两件事：创建一个全局对象，并且设置 `this` 的值等于这个全局对象。一个程序中只会有一个全局执行上下文。
> - 函数执行上下文 —— 每当一个函数被调用的时，都会为该函数创建一个新的上下文。每个函数都有自己的执行上下文，不过是在函数被调用时创建的。函数上下文可以有任意多个。每当一个新的执行上下文被创建，它会按 `定义的顺序` 执行一系列的步骤。
> - `Eval` 函数执行上下文 —— 执行在 `Eval` 函数内部的代码也会有属它属于自己的执行上下文，但是不推荐使用，暂不讨论。

## 怎么创建执行上下文  

创建执行上下文有两个阶段 `创建阶段Creation Phase` 和 `执行阶段Execution Phase`

### The Creation Phase  

- `LexicalEnvironment` component is created（创建词法环境）  
- `VariableEnvironment` component is created（创建变量环境）  

所以，执行上下文在概念上表示：

```text
ExecutionContext = {
    LexicalEnvironment = <ref. to LexicalEnvironment in memory>,
    VariableEnvironment = <ref. to VariableEnvironment in memory>,
}
```

#### Lexical Environment（词法环境）

官方的ES6文档对词法环境做的定义：

> **A Lexical Environment is a specification type used to define the association of Identifiers to specific variables and functions based upon the lexical nesting structure of ECMAScript code. A Lexical Environment consists of an `Environment Record` and a possibly null reference to an outer Lexical Environment.**

翻译：

> **词法环境是一种规范类型，基于 `ECMAScript` 代码的词法嵌套结构来定义`标识符`到具体变量和函数的关联。一个词法环境由环境记录器和一个可能是null的对外部词法环境的引用。**

简单来说 `词法环境` 是一种 `标识符-变量` 映射结构。（这里的标识符指的是变量/函数的名字，变量是对实际对象[包含函数类型对象]或 `primitive value` 的引用）

```javascript
var a = 20;
var b = 40;

function foo() {
    console.log('bar');
}
```

上面代码对应的词法环境：

```text
lexicalEnvironment = {
    a: 20,
    b: 40,
    foo: <ref. to foo function>
}
```

每一个 `词法环境` 都有三个组件:

- `Environment Record` 环境记录器
- `Reference to the outer environment` 外部环境的引用
- `This binding` This绑定

> Environment Record

环境记录器是存储 `变量` 和 `函数声明` 的地方。

环境记录器有三种类型：

- Declarative Environment Record
  - Function Environment Records
  - Module Environment Records
- Object Environment Record
- Global Environment Record

注意：对于函数环境来说，声明式环境记录器还包含了一个传递给函数的 `arguments` 对象和传递给函数的参数的 `length`

```javascript
function foo(a, b) {
    var c = a + b;
}
foo(2, 3);
// argument object
Arguments: { 0: 2, 1: 3, length: 2 },
```

#### Variable Environment

它也是一个词法环境，所以它有着词法环境定义的所有属性。

变量环境和词法环境的不同在于词法环境被用来存储函数声明和变量（let和const）绑定，而变量环境只用来存储变量绑定（var）

### The Execution Phase

在这个阶段，完成所有的变量赋值，最后执行代码
