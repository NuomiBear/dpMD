# JavaScript

## 内存

### 栈内存 存储基本数据类型的值

1.为js代码提供执行的环境（执行js代码的地方）  

2.基本数据类型的值是直接存放在栈内存中的

### 堆内存 存储引用类型的值

1.对象存储的是键值对  

2.函数存储的是代码字符串

### 内存释放

在项目中，我们的内存越少性能越好，我们需要把一些没用的内存处理掉

栈内存：一般情况下，函数执行形成栈内存，函数执行完，浏览器会把形成的栈内存自动释放

> 全局作用域在加载页面的时候执行，在关掉页面的时候销毁  
> 有时候执行完，栈内存不能被释放
>  
>```javascript
>var obj = {
>    name: 'acer',
>    fn: (function () {
>        var i = 10;
>        return function () {
>            i++;
>            console.log(i)
>        }
>    })()
>}
>obj.fn();
>obj.fn();
>```

![内存释放](02-01.png)

堆内存：var o = {} 当前对象对应的堆内存被变量o占用（ 占用了：堆内存地址赋值给变量了），堆内存是无法销毁的，o = null（null空对象指针，不指向任何的堆内存），此时上一次的堆内存就没有被占用了，浏览器会在空闲时间把没有被占用的堆内存自动释放（销毁/回收）IE浏览器是靠计数器来统计当前堆内存被占用的次数：当计数器统计为零次，说明没有人占用它，浏览器销毁这个堆内存

## 必包

函数执行，形成一个私有作用域，保护里面的私有变量不受外界的干扰，这种保护机制叫做 闭包

但是现在市面上，99%的IT开发者都认为：
​函数执行，形成一个不销毁的私有作用域，除了保护私有变量以外，还可以存储一些内容，这样的模式才是闭包

```javascript
var utils = (function () {
    return {

    }
})()
```

作用：
保护：形成私有作用域，保护里面的私有变量不受外界的干扰  

保存：函数执行形成一个私有作用域，函数执行完成，形成的这个栈内存一般情况下都会自动释放；
​但是还有二般情况：函数执行完成，当前私有作用域（栈内存）中的某一部分内容被栈内存以外的其它东西（变量/元素的事件）占用了，当前的栈内存就不能释放掉，也就形成了不销毁的私有作用域（里面的私有变量也不会销毁）

函数执行返回了一个`引用数据类型堆内存的地址`（并且堆内存隶属于这个作用域），在外面有一个变量接收了这个返回值，此时当前作用域就不能销毁（想要销毁，只需要让外面的变量赋值为null，也就是不占用当前作用域中的内容了）

## This
