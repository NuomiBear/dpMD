# JavaScript：继承

## new关键字

## 继承（显式继承和隐式继承）

### 原型继承

> 原型继承，并不是把父类的属性和方法COPY一份给子类，而是让子类的原型和父类原型之间搭建一个链接的桥梁，以后子类（或者子类的实例），可以通过原型链的查找机制，找到父类原型上的方法，从而调取这些方法使用即可 `Children.prototype = new Parent()`

步骤细节：

- 我们首先让子类的原型指向父类的实例，然后再向子类原型上扩展方法，防止提前增加方法，等原型重新指向后，之前在子类原型上扩展的方法都没用了（子类原型已经指向新的空间地址了）  

- 让子类原型重新指向父类实例，子类原型上原有的constructor就没有了，为了保证构造函数的完整性，我们最好给子类的原型重新手动设置constructor属性值：`Children.prototype.constructor = Children`

关键特征：

> 子类不仅可以继承父类原型上的公有属性和方法，而且父类提供给实例的那些私有的属性方法，也被子类继承了（存放在子类原型上，作为子类公有的属性和方法）

```javascript
function Parent() {
    this.x = 100
}
Parent.prototype.getX = function () {
    console.log(this.x)
}
function Children() {
    this.y = 200
}

// 子类原型执行父类的实例
Children.prototype = new Parent()
// 重新设置子类的原有的构造函数
Children.prototype.constructor = Children
// 子类新的原型上扩展方法
Children.prototype.getY = function () {
    console.log(this.y)
}

var child = new Children()
console.log(child)
```

### Object.create

Object.create() 静态方法以一个现有对象作为原型，创建一个新对象: `Object.create(proto, propertiesObject)`

TypeError：如果 proto 既不是 null，也不是 Object，则抛出此错误

### call继承

### 寄生组合继承
